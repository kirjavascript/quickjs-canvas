/// Contains the xzipped embedded Unifont planes which have been selected using
/// cargo features. The first time that the font is used, the embedded font
/// contents are decompressed and parsed into a fast hashmap structure which
/// makes character lookup quick.
///
/// None of the functions here should need to be invoked manually - it is
/// automatically handled by the renderer.
use std::boxed::Box;
use std::collections::HashMap;
use std::io::{BufRead, BufReader, Cursor, Error, ErrorKind};

use lzma::LzmaError;
use lzma::LzmaReader;

// NOTE: The following files are generated by build.rs

#[cfg(feature = "plane-0")]
/// Contains the raw file contents of the Unifont plane 0 font
const PLANE_0_RAW: &'static [u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/unifont-11.0.02.hex.xz"));

#[cfg(feature = "plane-1")]
/// Contains the raw file contents of the Unifont plane 1 font
const PLANE_1_RAW: &'static [u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/unifont_upper-11.0.02.hex.xz"));

/// The container type which relates Unicode code points with font character
/// definitions.
pub type FontChars = HashMap<u32, FontChar>;

/// Contains parsed character definitions. A hashmap is utilised for fast
/// look-ups, since there are often gaps between defined characters in the
/// Unifont files.
static mut UNIFONT: Option<Box<FontChars>> = None;

/// Describes a single character in the font.
pub struct FontChar {
    /// Width, either 8px (half-width) or 16px (full-width)
    pub width: u8,
    /// Array of lines of the character's form. MSB is unused for half-width
    /// characters
    pub bitmap: [u16; 16],
}

/// Decompresses a supplied embedded font file, before parsing the decompressed
/// result using `initialise_from_str`.
fn initialise_generic(font: &[u8]) -> Result<(), LzmaError> {
    // Mutate hashmap (we assume that if it's uninitialised, nobody else is
    // using it anyway)
    let hashmap = unsafe {
        match UNIFONT {
            None => return Err(LzmaError::Other),
            Some(ref mut hashmap) => hashmap,
        }
    };

    // Read decompressed embedded font line-by-line
    let cur = Cursor::new(font);
    let decomp = LzmaReader::new_decompressor(cur)?;
    let reader = BufReader::new(decomp);
    let lines = reader.lines();

    // Returned as the Result value if the font file is malformed
    let corrupt_file_err = Err(LzmaError::Io(Error::new(
        ErrorKind::InvalidData,
        "font file malformed",
    )));

    for l in lines {
        let line = l.unwrap();
        let mut split = line.split(":");

        // Parse code point of current character
        let codepoint = match split.next() {
            Some(cp) => match u32::from_str_radix(cp, 16) {
                Ok(cp_num) => cp_num,
                Err(_) => return corrupt_file_err,
            },

            None => return corrupt_file_err,
        };

        // Retrieve bitmap string
        let bitmap = match split.next() {
            Some(bmp) => bmp,
            None => return corrupt_file_err,
        };

        // Determine if current character is half or full-width
        let char_count = bitmap.chars().count();
        let char_width = char_count / 4;

        if char_width != 8 && char_width != 16 {
            return corrupt_file_err;
        }

        // Number of chars per pixel row
        let row_width = char_width / 4;

        // Create and load binary bitmap array
        let mut bitmap_arr: [u16; 16] = [0; 16];
        let mut bitmap_i = 0;

        for i in 0..char_count / row_width {
            let line = &bitmap[(i * row_width)..(i * row_width) + row_width];

            // Convert hex line bit pattern to binary
            bitmap_arr[bitmap_i] = match u16::from_str_radix(line, 16) {
                Ok(bit_line) => bit_line,
                Err(_) => return corrupt_file_err,
            };

            bitmap_i += 1;
        }

        // We have all the information we need; insert the completed character
        // into our global hashmap.
        hashmap.insert(
            codepoint,
            FontChar {
                width: char_width as u8,
                bitmap: bitmap_arr,
            },
        );
    }

    Ok(())
}

/// Called the first time that a reference to the `UNIFONT` hashmap is requested,
/// in order to decompress and parse the embedded, xzipped .hex contents
pub unsafe fn initialise_unifont() -> Result<(), LzmaError> {
    // Initialise UNIFONT variable, since it _should_ be None at the moment
    UNIFONT = Some(Box::new(HashMap::new()));

    #[cfg(feature = "plane-0")]
    initialise_generic(PLANE_0_RAW)?;

    #[cfg(feature = "plane-1")]
    initialise_generic(PLANE_1_RAW)?;

    Ok(())
}

/// Returns a safe, immutable reference to the parsed Unifont hashmap structure.
/// Initialises said structure if it hasn't already been.
pub fn get_unifont<'a>() -> Result<&'a FontChars, LzmaError> {
    unsafe {
        match UNIFONT {
            None => match initialise_unifont() {
                Ok(_) => get_unifont(),
                Err(e) => {
                    UNIFONT = None;
                    return Err(e);
                }
            },

            Some(ref unifont) => Ok(unifont),
        }
    }
}
